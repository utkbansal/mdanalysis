<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.universe &mdash; MDAnalysis 0.16.0-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.16.0-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.16.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.16.0-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.universe</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding: utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c1"># and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">=========================================================</span>
<span class="sd">Core object: Universe --- :mod:`MDAnalysis.core.universe`</span>
<span class="sd">=========================================================</span>

<span class="sd">The :class:`~MDAnalysis.core.universe.Universe` class ties a topology</span>
<span class="sd">and a trajectory together. Almost all code in MDAnalysis starts with a</span>
<span class="sd">``Universe``.</span>

<span class="sd">Normally, a ``Universe`` is created from files::</span>

<span class="sd">  import MDAnalysis as mda</span>
<span class="sd">  u = mda.Universe(&quot;topology.psf&quot;, &quot;trajectory.dcd&quot;)</span>

<span class="sd">In order to construct new simulation system it is also convenient to</span>
<span class="sd">construct a ``Universe`` from existing</span>
<span class="sd">:class:`~MDAnalysis.core.group.AtomGroup` instances with the</span>
<span class="sd">:func:`Merge` function.</span>


<span class="sd">Classes</span>
<span class="sd">=======</span>

<span class="sd">.. autoclass:: Universe</span>
<span class="sd">   :members:</span>

<span class="sd">Functions</span>
<span class="sd">=========</span>

<span class="sd">.. autofunction:: Merge</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">MDAnalysis</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..lib.log</span> <span class="kn">import</span> <span class="n">ProgressMeter</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="kn">import</span> <span class="n">NoDataError</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">groups</span>
<span class="kn">from</span> <span class="nn">.groups</span> <span class="kn">import</span> <span class="p">(</span><span class="n">GroupBase</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span>
                     <span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.topology</span> <span class="kn">import</span> <span class="n">Topology</span>
<span class="kn">from</span> <span class="nn">.topologyattrs</span> <span class="kn">import</span> <span class="n">AtomAttr</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">,</span> <span class="n">SegmentAttr</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;MDAnalysis.core.universe&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Universe"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe">[docs]</a><span class="k">class</span> <span class="nc">Universe</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The MDAnalysis Universe contains all the information describing the system.</span>

<span class="sd">    The system always requires a *topology* file --- in the simplest case just</span>
<span class="sd">    a list of atoms. This can be a CHARMM/NAMD PSF file or a simple coordinate</span>
<span class="sd">    file with atom informations such as XYZ, PDB, Gromacs GRO, or CHARMM</span>
<span class="sd">    CRD. See :ref:`Supported topology formats` for what kind of topologies can</span>
<span class="sd">    be read.</span>

<span class="sd">    A trajectory provides coordinates; the coordinates have to be ordered in</span>
<span class="sd">    the same way as the list of atoms in the topology. A trajectory can be a</span>
<span class="sd">    single frame such as a PDB, CRD, or GRO file, or it can be a MD trajectory</span>
<span class="sd">    (in CHARMM/NAMD/LAMMPS DCD, Gromacs XTC/TRR, or generic XYZ format).  See</span>
<span class="sd">    :ref:`Supported coordinate formats` for what can be read as a</span>
<span class="sd">    &quot;trajectory&quot;.</span>

<span class="sd">    As a special case, when the topology is a file that contains atom</span>
<span class="sd">    information *and* coordinates (such as XYZ, PDB, GRO or CRD, see</span>
<span class="sd">    :ref:`Supported coordinate formats`) then the coordinates are immediately</span>
<span class="sd">    loaded from the &quot;topology&quot; file unless a trajectory is supplied.</span>

<span class="sd">    Examples for setting up a universe::</span>

<span class="sd">       u = Universe(topology, trajectory)          # read system from file(s)</span>
<span class="sd">       u = Universe(pdbfile)                       # read atoms and coordinates from PDB or GRO</span>
<span class="sd">       u = Universe(topology, [traj1, traj2, ...]) # read from a list of trajectories</span>
<span class="sd">       u = Universe(topology, traj1, traj2, ...)   # read from multiple trajectories</span>

<span class="sd">    Load new data into a universe (replaces old trajectory and does *not* append)::</span>

<span class="sd">       u.load_new(trajectory)                      # read from a new trajectory file</span>

<span class="sd">    Select atoms, with syntax similar to CHARMM (see</span>
<span class="sd">    :class:`~Universe.select_atoms` for details)::</span>

<span class="sd">       u.select_atoms(...)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    topology : filename or Topology object</span>
<span class="sd">        A CHARMM/XPLOR PSF topology file, PDB file or Gromacs GRO file; used to</span>
<span class="sd">        define the list of atoms. If the file includes bond information,</span>
<span class="sd">        partial charges, atom masses, ... then these data will be available to</span>
<span class="sd">        MDAnalysis. A &quot;structure&quot; file (PSF, PDB or GRO, in the sense of a</span>
<span class="sd">        topology) is always required. Alternatively, an existing</span>
<span class="sd">        :class:`MDAnalysis.core.topology.Topology` instance may also be given.</span>
<span class="sd">    topology_format</span>
<span class="sd">        Provide the file format of the topology file; ``None`` guesses it from</span>
<span class="sd">        the file extension [``None``] Can also pass a subclass of</span>
<span class="sd">        :class:`MDAnalysis.topology.base.TopologyReader` to define a custom</span>
<span class="sd">        reader to be used on the topology file.</span>
<span class="sd">    format</span>
<span class="sd">        Provide the file format of the coordinate or trajectory file; ``None``</span>
<span class="sd">        guesses it from the file extension. Note that this keyword has no</span>
<span class="sd">        effect if a list of file names is supplied because the &quot;chained&quot; reader</span>
<span class="sd">        has to guess the file format for each individual list member.</span>
<span class="sd">        [``None``] Can also pass a subclass of</span>
<span class="sd">        :class:`MDAnalysis.coordinates.base.Reader` to define a custom reader</span>
<span class="sd">        to be used on the trajectory file.</span>
<span class="sd">    guess_bonds</span>
<span class="sd">        Once Universe has been loaded, attempt to guess the connectivity</span>
<span class="sd">        between atoms.  This will populate the .bonds .angles and .dihedrals</span>
<span class="sd">        attributes of the Universe.</span>
<span class="sd">    vdwradii</span>
<span class="sd">        For use with *guess_bonds*. Supply a dict giving a vdwradii for each</span>
<span class="sd">        atom type which are used in guessing bonds.</span>
<span class="sd">    is_anchor</span>
<span class="sd">        When unpickling instances of</span>
<span class="sd">        :class:`MDAnalysis.core.groups.AtomGroup` existing Universes are</span>
<span class="sd">        searched for one where to anchor those atoms. Set to ``False`` to</span>
<span class="sd">        prevent this Universe from being considered. [``True``]</span>
<span class="sd">    anchor_name</span>
<span class="sd">        Setting to other than ``None`` will cause</span>
<span class="sd">        :class:`MDAnalysis.core.groups.AtomGroup` instances pickled from the</span>
<span class="sd">        Universe to only unpickle if a compatible Universe with matching</span>
<span class="sd">        *anchor_name* is found. *is_anchor* will be ignored in this case but</span>
<span class="sd">        will still be honored when unpickling</span>
<span class="sd">        :class:`MDAnalysis.core.groups.AtomGroup` instances pickled with</span>
<span class="sd">        *anchor_name*==``None``. [``None``]</span>
<span class="sd">    in_memory</span>
<span class="sd">        After reading in the trajectory, transfer it to an in-memory</span>
<span class="sd">        representations, which allow for manipulation of coordinates.</span>
<span class="sd">    in_memory_frame_interval</span>
<span class="sd">        Only read every nth frame into in-memory representation.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    trajectory</span>
<span class="sd">        currently loaded trajectory reader;</span>
<span class="sd">    dimensions</span>
<span class="sd">        current system dimensions (simulation unit cell, if set in the</span>
<span class="sd">        trajectory)</span>
<span class="sd">    atoms, residues, segments</span>
<span class="sd">        master Groups for each topology level</span>
<span class="sd">    bonds, angles, dihedrals</span>
<span class="sd">        master ConnectivityGroups for each connectivity type</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..topology.core</span> <span class="kn">import</span> <span class="n">get_parser_for</span>
        <span class="kn">from</span> <span class="nn">..topology.base</span> <span class="kn">import</span> <span class="n">TopologyReader</span>
        <span class="kn">from</span> <span class="nn">..coordinates.base</span> <span class="kn">import</span> <span class="n">ProtoReader</span>

        <span class="c1"># hold on to copy of kwargs; used by external libraries that</span>
        <span class="c1"># reinitialize universes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># managed attribute holding Reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># create an empty universe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span>

        <span class="n">coordinatefile</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">coordinatefile</span><span class="p">:</span>
            <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># if we&#39;re given a Topology object, we don&#39;t need to parse anything</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Topology</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;topology_format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># special hacks to treat a coordinate file as a coordinate AND</span>
                <span class="c1"># topology file</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">topology_format</span>
                <span class="k">elif</span> <span class="n">topology_format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">topology_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

                <span class="c1"># if passed a Reader, use that</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">ProtoReader</span><span class="p">):</span>
                        <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># or if file is known as a topology &amp; coordinate file, use</span>
                    <span class="c1"># that</span>
                    <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">fmt</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">guess_format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">fmt</span> <span class="ow">in</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">_READERS</span>
                            <span class="ow">and</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">_PARSERS</span><span class="p">):</span>
                        <span class="n">coordinatefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span>

            <span class="c1"># build the topology (or at least a list of atoms)</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># Try and check if the topology format is a TopologyReader</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">topology_format</span><span class="p">,</span> <span class="n">TopologyReader</span><span class="p">):</span>
                    <span class="n">parser</span> <span class="o">=</span> <span class="n">topology_format</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># But strings/None raise TypeError in issubclass</span>
                <span class="n">parser</span> <span class="o">=</span> <span class="n">get_parser_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                                        <span class="n">format</span><span class="o">=</span><span class="n">topology_format</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Failed to load from the topology file {0}&quot;</span>
                              <span class="s2">&quot; with parser {1}.</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;Error: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to construct topology from file {0}&quot;</span>
                                 <span class="s2">&quot; with parser {1} </span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;Error: {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>

        <span class="c1"># generate and populate Universe version of each class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_from_topology</span><span class="p">()</span>

        <span class="c1"># Load coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_new</span><span class="p">(</span><span class="n">coordinatefile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check for guess_bonds</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;guess_bonds&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">guess_bonds</span><span class="p">(</span><span class="n">vdwradii</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vdwradii&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_generate_from_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># generate Universe version of each class</span>
        <span class="c1"># AG, RG, SG, A, R, S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classes</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">make_classes</span><span class="p">()</span>

        <span class="c1"># Put Group level stuff from topology into class</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="c1"># Generate atoms, residues and segments.</span>
        <span class="c1"># These are the first such groups generated for this universe, so</span>
        <span class="c1">#  there are no cached merged classes yet. Otherwise those could be</span>
        <span class="c1">#  used directly to get a (very) small speedup. (Only really pays off</span>
        <span class="c1">#  the readability loss if instantiating millions of AtomGroups at</span>
        <span class="c1">#  once.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">AtomGroup</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span> <span class="o">=</span> <span class="n">ResidueGroup</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_residues</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">SegmentGroup</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_segments</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Update Universe namespace with segids</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="s1">&#39;segid&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">seg</span><span class="o">.</span><span class="n">segid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">segid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span> <span class="o">+</span> <span class="n">seg</span><span class="o">.</span><span class="n">segid</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">segid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for Writer.write(universe), see Issue 49</span>
        <span class="c1"># Encapsulation in an accessor prevents the Universe from</span>
        <span class="c1"># having to keep a reference to itself,</span>
        <span class="c1">#  which might be undesirable if it has a __del__ method.</span>
        <span class="c1"># It is also cleaner than a weakref.</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Universe.load_new"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.load_new">[docs]</a>    <span class="k">def</span> <span class="nf">load_new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">in_memory</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load coordinates from `filename`.</span>

<span class="sd">        The file format of `filename` is autodetected from the file name suffix</span>
<span class="sd">        or can be explicitly set with the `format` keyword. A sequence of files</span>
<span class="sd">        can be read as a single virtual trajectory by providing a list of</span>
<span class="sd">        filenames.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str or list</span>
<span class="sd">            the coordinate file (single frame or trajectory) *or* a list of</span>
<span class="sd">            filenames, which are read one after another.</span>
<span class="sd">        format : str or list or object (optional)</span>
<span class="sd">            provide the file format of the coordinate or trajectory file;</span>
<span class="sd">            ``None`` guesses it from the file extension. Note that this</span>
<span class="sd">            keyword has no effect if a list of file names is supplied because</span>
<span class="sd">            the &quot;chained&quot; reader has to guess the file format for each</span>
<span class="sd">            individual list member [``None``]. Can also pass a subclass of</span>
<span class="sd">            :class:`MDAnalysis.coordinates.base.Reader` to define a custom</span>
<span class="sd">            reader to be used on the trajectory file.</span>
<span class="sd">        in_memory : bool (optional)</span>
<span class="sd">            Directly load trajectory into memory with the</span>
<span class="sd">            :class:`~MDAnalysis.coordinates.memory.MemoryReader`</span>

<span class="sd">            .. versionadded:: 0.16.0</span>

<span class="sd">        **kwargs : dict</span>
<span class="sd">            Other kwargs are passed to the trajectory reader (only for</span>
<span class="sd">            advanced use)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : str or list</span>
<span class="sd">        trajectory_format : str</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if trajectory format can not be</span>
<span class="sd">                  determined or no appropriate trajectory reader found</span>


<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">           If a list or sequence that is provided for `filename` only contains</span>
<span class="sd">           a single entry then it is treated as single coordinate file. This</span>
<span class="sd">           has the consequence that it is not read by the</span>
<span class="sd">           :class:`~MDAnalysis.coordinates.chain.ChainReader` but directly by</span>
<span class="sd">           its specialized file format reader, which typically has more</span>
<span class="sd">           features than the</span>
<span class="sd">           :class:`~MDAnalysis.coordinates.chain.ChainReader`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the following was in the doc string:</span>
        <span class="c1"># TODO</span>
        <span class="c1"># ----</span>
        <span class="c1"># - check what happens if filename is ``None``</span>
        <span class="c1"># - look up raises doc formating</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># TODO: is this really sensible? Why not require a filename arg?</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="kn">from</span> <span class="nn">..coordinates.core</span> <span class="kn">import</span> <span class="n">get_reader_for</span>
        <span class="kn">from</span> <span class="nn">..coordinates.base</span> <span class="kn">import</span> <span class="n">ProtoReader</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># make sure a single filename is not handed to the ChainReader</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">asiterable</span><span class="p">(</span><span class="n">filename</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Universe.load_new(): loading {0}...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

        <span class="n">reader_format</span> <span class="o">=</span> <span class="n">format</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Check if we were passed a Reader to use</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reader_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">reader_format</span><span class="p">,</span> <span class="n">ProtoReader</span><span class="p">):</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">reader_format</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">reader</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Check if we need to use ChainReader</span>
            <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
                <span class="c1"># Save the format and pass this to ChainReader</span>
                <span class="n">reader_format</span> <span class="o">=</span> <span class="s1">&#39;CHAIN&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reader_format</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">reader</span> <span class="o">=</span> <span class="n">get_reader_for</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                                        <span class="n">format</span><span class="o">=</span><span class="n">reader_format</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot find an appropriate coordinate reader for file &#39;{0}&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;           {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
        <span class="c1"># supply number of atoms for readers that cannot do it for themselves</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">n_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The topology and {form} trajectory files don&#39;t&quot;</span>
                             <span class="s2">&quot; have the same number of atoms!</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Topology number of atoms {top_n_atoms}</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Trajectory: {fname} Number of atoms {trj_n_atoms}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="n">form</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                                 <span class="n">top_n_atoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">),</span>
                                 <span class="n">fname</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
                                 <span class="n">trj_n_atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">in_memory</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transfer_to_memory</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;in_memory_frame_interval&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">format</span></div>

<div class="viewcode-block" id="Universe.transfer_to_memory"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.transfer_to_memory">[docs]</a>    <span class="k">def</span> <span class="nf">transfer_to_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transfer the trajectory to in memory representation.</span>

<span class="sd">        Replaces the current trajectory reader object with one of type</span>
<span class="sd">        :class:`MDAnalysis.coordinates.memory.MemoryReader` to support in-place</span>
<span class="sd">        editing of coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frame_interval : int, optional</span>
<span class="sd">            Read in every nth frame. [1]</span>
<span class="sd">        quiet : bool, optional</span>
<span class="sd">            Will print the progress of loading trajectory to memory, if</span>
<span class="sd">            set to True. Default value is quiet.</span>


<span class="sd">        .. versionadded:: 0.16.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..coordinates.memory</span> <span class="kn">import</span> <span class="n">MemoryReader</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">MemoryReader</span><span class="p">):</span>
            <span class="c1"># Try to extract coordinates using Timeseries object</span>
            <span class="c1"># This is significantly faster, but only implemented for certain</span>
            <span class="c1"># trajectory file formats</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">timeseries</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;afc&#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">frame_interval</span><span class="p">)</span>
            <span class="c1"># if the Timeseries extraction fails,</span>
            <span class="c1"># fall back to a slower approach</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">pm</span> <span class="o">=</span> <span class="n">ProgressMeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                                   <span class="n">interval</span><span class="o">=</span><span class="n">frame_interval</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">)</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># TODO: use pre-allocated array</span>
                <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[::</span><span class="n">frame_interval</span><span class="p">]:</span>
                    <span class="n">coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>
                    <span class="n">pm</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Overwrite trajectory in universe with an MemoryReader</span>
            <span class="c1"># object, to provide fast access and allow coordinates</span>
            <span class="c1"># to be manipulated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">MemoryReader</span><span class="p">(</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">dimensions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Universe.select_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.select_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">select_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Select atoms.</span>

<span class="sd">        SeeAlso</span>
<span class="sd">        -------</span>
<span class="sd">        :meth:`MDAnalysis.core.groups.AtomGroup.select_atoms`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel</span><span class="p">,</span> <span class="o">*</span><span class="n">othersel</span><span class="p">,</span> <span class="o">**</span><span class="n">selgroups</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bonds between atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">bonds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Angles between atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">angles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dihedral angles between atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">dihedrals</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Improper dihedral angles between atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">impropers</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># return &quot;&lt;Universe with {n_atoms} atoms{bonds}&gt;&quot;.format(</span>
        <span class="c1">#    n_atoms=len(self.atoms),</span>
        <span class="c1">#    bonds=&quot; and {0} bonds&quot;.format(len(self.bonds)) if self.bonds else &quot;&quot;)</span>

        <span class="k">return</span> <span class="s2">&quot;&lt;Universe with {n_atoms} atoms&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">n_atoms</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># Properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Current dimensions of the unitcell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">dimensions</span>

    <span class="nd">@dimensions.setter</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set dimensions if the Timestep allows this</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add fancy error handling here or use Timestep?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">box</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to current timestep and coordinates of universe.</span>

<span class="sd">        The raw trajectory coordinates are :attr:`Universe.coord.positions`,</span>
<span class="sd">        represented as a :class:`numpy.float32` array.</span>

<span class="sd">        Because :attr:`coord` is a reference to a</span>
<span class="sd">        :class:`~MDAnalysis.coordinates.base.Timestep`, it changes its contents</span>
<span class="sd">        while one is stepping through the trajectory.</span>

<span class="sd">        .. Note::</span>

<span class="sd">           In order to access the coordinates it is better to use the</span>
<span class="sd">           :meth:`AtomGroup.positions` method; for instance, all coordinates of</span>
<span class="sd">           the Universe as a numpy array: :meth:`Universe.atoms.positions`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajectory</span><span class="o">.</span><span class="n">ts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;keyword arguments used to initialize this universe&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reference to trajectory reader object containing trajectory data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No trajectory loaded into Universe&quot;</span><span class="p">)</span>

    <span class="nd">@trajectory.setter</span>
    <span class="k">def</span> <span class="nf">trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span>  <span class="c1"># guarantees that files are closed (?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trajectory</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Universe.add_TopologyAttr"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.add_TopologyAttr">[docs]</a>    <span class="k">def</span> <span class="nf">add_TopologyAttr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topologyattr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new topology attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">add_TopologyAttr</span><span class="p">(</span><span class="n">topologyattr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_attr</span><span class="p">(</span><span class="n">topologyattr</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Squeeze a topologyattr for its information</span>

<span class="sd">        Grabs:</span>
<span class="sd">         - Group properties (attribute access)</span>
<span class="sd">         - Component properties</span>
<span class="sd">         - Transplant methods</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;atom&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span>
                  <span class="s1">&#39;residue&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span>
                  <span class="s1">&#39;segment&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_segments</span><span class="p">}</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;_process_attr: Adding {0} to topology&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">per_object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_dict</span><span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">per_object</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of {attr} does not&#39;</span>
                             <span class="s1">&#39; match number of {obj}s.</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;Expect: {n:d} Have: {m:d}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                                 <span class="n">obj</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">per_object</span><span class="p">,</span>
                                 <span class="n">n</span><span class="o">=</span><span class="n">n_dict</span><span class="p">[</span><span class="n">attr</span><span class="o">.</span><span class="n">per_object</span><span class="p">],</span>
                                 <span class="n">m</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">attr</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">_add_prop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">target_classes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span><span class="o">.</span><span class="n">_add_prop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">transplants</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">transplants</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># not every Attribute will have a transplant dict</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Group transplants</span>
            <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                        <span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">transplants</span><span class="p">[</span><span class="n">cls</span><span class="p">]:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_class_bases</span><span class="p">[</span><span class="n">cls</span><span class="p">],</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
            <span class="c1"># Universe transplants</span>
            <span class="k">for</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">transplants</span><span class="p">[</span><span class="s1">&#39;Universe&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>

<div class="viewcode-block" id="Universe.add_Residue"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.add_Residue">[docs]</a>    <span class="k">def</span> <span class="nf">add_Residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new Residue to this Universe</span>

<span class="sd">        New Residues will not contain any Atoms, but can be assigned to Atoms</span>
<span class="sd">        as per usual.  If the Universe contains multiple segments, this must</span>
<span class="sd">        be specified as a keyword.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment : MDAnalysis.Segment</span>
<span class="sd">          If there are multiple segments, then the Segment that the new</span>
<span class="sd">          Residue will belong in must be specified.</span>
<span class="sd">        attrs : dict</span>
<span class="sd">          For each Residue attribute, the value for the new Residue must be</span>
<span class="sd">          specified</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A reference to the new Residue</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NoDataError</span>
<span class="sd">          If any information was missing.  This happens before any changes have</span>
<span class="sd">          been made, ie the change is rolled back.</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        Adding a new GLY residue, then placing atoms within it:</span>

<span class="sd">        &gt;&gt;&gt; newres = u.add_Residue(segment=u.segments[0], resid=42, resname=&#39;GLY&#39;)</span>
<span class="sd">        &gt;&gt;&gt; u.atoms[[1, 2, 3]].residues = newres</span>
<span class="sd">        &gt;&gt;&gt; u.select_atoms(&#39;resname GLY and resid 42&#39;)</span>
<span class="sd">        &lt;AtomGroup with 3 atoms&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if only one segment, use this</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NoDataError</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># pass this information to the topology</span>
        <span class="n">residx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">add_Residue</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
        <span class="c1"># resize my residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residues</span> <span class="o">=</span> <span class="n">ResidueGroup</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_residues</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># return the new residue</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="p">[</span><span class="n">residx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Universe.add_Segment"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Universe.add_Segment">[docs]</a>    <span class="k">def</span> <span class="nf">add_Segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new Segment to this Universe</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attrs : dict</span>
<span class="sd">            For each Segment attribute as a key, give the value in the new</span>
<span class="sd">            Segment</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A reference to the new Segment</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NoDataError</span>
<span class="sd">            If any attributes were not specified as a keyword.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pass this information to the topology</span>
        <span class="n">segidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">add_Segment</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
        <span class="c1"># resize my segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segments</span> <span class="o">=</span> <span class="n">SegmentGroup</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_topology</span><span class="o">.</span><span class="n">n_segments</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># return the new segment</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">[</span><span class="n">segidx</span><span class="p">]</span></div>

    <span class="c1"># TODO: Maybe put this as a Bond attribute transplant</span>
    <span class="c1"># Problems: Can we transplant onto Universe?</span>
    <span class="c1"># Probably a smarter way to do this too, could generate</span>
    <span class="c1"># these on demand *per atom*.</span>
    <span class="c1"># Wouldn&#39;t then need the Universe linkage here</span>
    <span class="c1">#</span>
    <span class="c1"># Alternate idea: Bonds Attribute generates a Fragments</span>
    <span class="c1"># Attribute (ie, 2 for the price of 1)</span>
    <span class="c1"># Fragments then gets its own Class/namespace/jazz.</span>
    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_fragdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.16.0</span>
<span class="sd">           Fragment atoms are sorted by their index, and framgents are sorted</span>
<span class="sd">           by their first atom index so their order is predictable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">bonds</span>

        <span class="k">class</span> <span class="nc">_fragset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ats&#39;</span><span class="p">]</span>
            <span class="sd">&quot;&quot;&quot;Normal sets aren&#39;t hashable, this is&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ats</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ats</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ats</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">ats</span><span class="p">)</span>

        <span class="c1"># each atom starts with its own list</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="ow">in</span> <span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]):</span>
                <span class="c1"># New set made here</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">_fragset</span><span class="p">([</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">])</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
            <span class="k">elif</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>
                <span class="c1"># If a2 isn&#39;t in a fragment, add it to a1&#39;s</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>
                <span class="c1"># If a1 isn&#39;t in a fragment, add it to a2&#39;s</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]:</span>
                <span class="c1"># If they&#39;re in the same fragment, do nothing</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If they are both in different fragments, combine fragments</span>
                <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">])</span>
                <span class="n">f</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">a1</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">a2</span><span class="p">]))</span>

        <span class="c1"># Lone atoms get their own fragment</span>
        <span class="n">f</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">_fragset</span><span class="p">((</span><span class="n">a</span><span class="p">,)))</span>
                      <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">))</span>

        <span class="c1"># All the unique values in f are the fragments</span>
        <span class="n">frags</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="n">AtomGroup</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">at</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">ag</span><span class="p">])),</span> <span class="bp">self</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">values</span><span class="p">())],</span>
        <span class="p">)</span>

        <span class="n">fragdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">fragdict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">fragdict</span></div>


<span class="c1"># TODO: what is the point of this function???</span>
<span class="k">def</span> <span class="nf">as_Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a universe from the input arguments.</span>

<span class="sd">    1. If the first argument is a universe, just return it::</span>

<span class="sd">         as_Universe(universe) --&gt; universe</span>

<span class="sd">    2. Otherwise try to build a universe from the first or the first</span>
<span class="sd">       and second argument::</span>

<span class="sd">         as_Universe(PDB, **kwargs) --&gt; Universe(PDB, **kwargs)</span>
<span class="sd">         as_Universe(PSF, DCD, **kwargs) --&gt; Universe(PSF, DCD, **kwargs)</span>
<span class="sd">         as_Universe(*args, **kwargs) --&gt; Universe(*args, **kwargs)</span>

<span class="sd">    :Returns: an instance of :class:`~MDAnalysis.core.groups.Universe`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;as_Universe() takes at least one argument (</span><span class="si">%d</span><span class="s2"> given)&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Universe</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Universe</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="Merge"><a class="viewcode-back" href="../../../documentation_pages/core/universe.html#MDAnalysis.core.universe.Merge">[docs]</a><span class="k">def</span> <span class="nf">Merge</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a new new :class:`Universe` from one or more</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.AtomGroup` instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : :class:`~MDAnalysis.core.groups.AtomGroup`</span>
<span class="sd">        One or more AtomGroups.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    universe : :class:`Universe`</span>

<span class="sd">    :Raises: :exc:`ValueError` for too few arguments or if an AtomGroup is</span>
<span class="sd">             empty and :exc:`TypeError` if arguments are not</span>
<span class="sd">             :class:`AtomGroup` instances.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The resulting :class:`Universe` will only inherit the common topology</span>
<span class="sd">    attributes that all merged universes share.</span>

<span class="sd">    :class:`AtomGroup` instances can come from different Universes, or can come</span>
<span class="sd">    directly from a :meth:`~Universe.select_atoms` call.</span>

<span class="sd">    :class:`Merge` can also be used with a single :class:`AtomGroup` if the</span>
<span class="sd">    user wants to, for example, re-order the atoms in the :class:`Universe`.</span>

<span class="sd">    If multiple :class:`AtomGroup` instances from the same :class:`Universe`</span>
<span class="sd">    are given, the merge will first simply &quot;add&quot; together the</span>
<span class="sd">    :class:`AtomGroup` instances.</span>

<span class="sd">    Merging does not create a full trajectory but only a single structure even</span>
<span class="sd">    if the input consists of one or more trajectories.  However, one can use</span>
<span class="sd">    the :class:`~MDAnalysis.coordinates.memory.MemoryReader` to construct a</span>
<span class="sd">    trajectory for the new Universe as described under</span>
<span class="sd">    :ref:`creating-in-memory-trajectory-label`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    In this example, protein, ligand, and solvent were externally prepared in</span>
<span class="sd">    three different PDB files. They are loaded into separate :class:`Universe`</span>
<span class="sd">    objects (where they could be further manipulated, e.g. renumbered,</span>
<span class="sd">    relabeled, rotated, ...) The :func:`Merge` command is used to combine all</span>
<span class="sd">    of them together::</span>

<span class="sd">       u1 = Universe(&quot;protein.pdb&quot;)</span>
<span class="sd">       u2 = Universe(&quot;ligand.pdb&quot;)</span>
<span class="sd">       u3 = Universe(&quot;solvent.pdb&quot;)</span>
<span class="sd">       u = Merge(u1.select_atoms(&quot;protein&quot;), u2.atoms, u3.atoms)</span>
<span class="sd">       u.atoms.write(&quot;system.pdb&quot;)</span>

<span class="sd">    The complete system is then written out to a new PDB file.</span>


<span class="sd">    .. versionchanged 0.9.0::</span>
<span class="sd">       Raises exceptions instead of assertion errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..topology.base</span> <span class="kn">import</span> <span class="n">squash_by</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one AtomGroup for merging&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">groups</span><span class="o">.</span><span class="n">AtomGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; is not an AtomGroup&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot merge empty AtomGroup&quot;</span><span class="p">)</span>

    <span class="c1"># Create a new topology using the intersection of topology attributes</span>
    <span class="n">blank_topology_attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">Topology</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">[])))</span>
    <span class="n">common_attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="p">))</span>
                                      <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">tops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span> <span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span> <span class="s1">&#39;impropers&#39;</span><span class="p">])</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create set of attributes which are array-valued and can be simply</span>
    <span class="c1"># concatenated together</span>
    <span class="n">common_array_attrs</span> <span class="o">=</span> <span class="n">common_attrs</span> <span class="o">-</span> <span class="n">blank_topology_attrs</span> <span class="o">-</span> <span class="n">tops</span>
    <span class="c1"># Build up array-valued topology attributes including only attributes</span>
    <span class="c1"># that all arguments&#39; universes have</span>
    <span class="k">for</span> <span class="n">attrname</span> <span class="ow">in</span> <span class="n">common_array_attrs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>
            <span class="n">attr_class</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="n">attrname</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">attr_class</span><span class="p">,</span> <span class="n">AtomAttr</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">attr_class</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">):</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">attr_class</span><span class="p">,</span> <span class="n">SegmentAttr</span><span class="p">):</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to handle&quot;</span>
                                          <span class="s2">&quot; TopologyAttr not subclassed&quot;</span>
                                          <span class="s2">&quot; from AtomAttr, ResidueAttr,&quot;</span>
                                          <span class="s2">&quot; or SegmentAttr.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Encountered unexpected topology &#39;</span>
                                <span class="s1">&#39;attribute of type {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attr_array</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">attr_array</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_class</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">attr_array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
        <span class="k">del</span> <span class="n">attr_array</span>

    <span class="c1"># Build up topology groups including only those that all arguments&#39;</span>
    <span class="c1"># universes have</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">tops</span> <span class="o">&amp;</span> <span class="n">common_attrs</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bondidx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># create a mapping scheme for this atomgroup</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">offset</span><span class="p">)}</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span>

            <span class="n">tg</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">bonds_class</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_topology</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
            <span class="c1"># Create a topology group of only bonds that are within this ag</span>
            <span class="c1"># ie we don&#39;t want bonds that extend out of the atomgroup</span>
            <span class="n">tg</span> <span class="o">=</span> <span class="n">tg</span><span class="o">.</span><span class="n">atomgroup_intersection</span><span class="p">(</span><span class="n">ag</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c1"># Map them so they refer to our new indices</span>
            <span class="n">new_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">mapping</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">entry</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">tg</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">bondidx</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tg</span><span class="p">,</span> <span class="s1">&#39;_bondtypes&#39;</span><span class="p">):</span>
                <span class="n">types</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tg</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">types</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tg</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bonds_class</span><span class="p">(</span><span class="n">bondidx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;|S8&#39;</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bonds_class</span><span class="p">(</span><span class="n">bondidx</span><span class="p">,</span> <span class="n">types</span><span class="p">))</span>

    <span class="c1"># Renumber residue and segment indices</span>
    <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">residx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">segidx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">seg_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ag</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="c1"># create a mapping scheme for this atomgroup&#39;s parents</span>
        <span class="n">res_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">resindex</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">residues</span><span class="p">,</span>
                                                           <span class="n">start</span><span class="o">=</span><span class="n">res_offset</span><span class="p">)}</span>
        <span class="n">seg_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">segindex</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span>
                                                           <span class="n">start</span><span class="o">=</span><span class="n">seg_offset</span><span class="p">)}</span>
        <span class="n">res_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>
        <span class="n">seg_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

        <span class="c1"># Map them so they refer to our new indices</span>
        <span class="n">residx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">res_mapping</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">resindices</span><span class="p">])</span>
        <span class="n">segidx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">seg_mapping</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">segindices</span><span class="p">])</span>

    <span class="n">residx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">residx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">segidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">segidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="p">[</span><span class="n">segidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">squash_by</span><span class="p">(</span><span class="n">residx</span><span class="p">,</span> <span class="n">segidx</span><span class="p">)</span>

    <span class="n">n_residues</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">residx</span><span class="p">))</span>
    <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">segidx</span><span class="p">))</span>

    <span class="n">top</span> <span class="o">=</span> <span class="n">Topology</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_residues</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">,</span>
                   <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
                   <span class="n">atom_resindex</span><span class="o">=</span><span class="n">residx</span><span class="p">,</span>
                   <span class="n">residue_segindex</span><span class="o">=</span><span class="n">segidx</span><span class="p">)</span>

    <span class="c1"># Create blank Universe only from topology</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>

    <span class="c1"># Take one frame of coordinates from combined atomgroups</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">positions</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="n">trajectory</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">Timestep</span><span class="o">.</span><span class="n">from_coordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="s2">&quot;ts&quot;</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>
    <span class="n">trajectory</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span>

    <span class="k">return</span> <span class="n">u</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Wouter Boomsma, Bart Bruininks, Sbastien Buchoux, David Caplan, Matthieu Chavent, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Matteo Tiberti, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>