<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.topologyobjects &mdash; MDAnalysis 0.16.0-dev0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.16.0-dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.16.0-dev0 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="top" title="MDAnalysis 0.16.0-dev0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/mdanalysis-logo-200x150.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.topologyobjects</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.MDAnalysis.org</span>
<span class="c1"># Copyright (c) 2006-2015 Naveen Michaud-Agrawal, Elizabeth J. Denning, Oliver Beckstein</span>
<span class="c1"># and contributors (see AUTHORS for the full list)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core Topology Objects --- :mod:`MDAnalysis.core.topologyobjects`</span>
<span class="sd">================================================================</span>

<span class="sd">The building blocks for MDAnalysis&#39; description of topology</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">from</span> <span class="nn">..lib.mdamath</span> <span class="kn">import</span> <span class="n">norm</span><span class="p">,</span> <span class="n">dihedral</span>
<span class="kn">from</span> <span class="nn">..lib.mdamath</span> <span class="kn">import</span> <span class="n">angle</span> <span class="k">as</span> <span class="n">slowang</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="kn">import</span> <span class="n">cached</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="kn">import</span> <span class="n">distances</span>


<span class="nd">@functools.total_ordering</span>
<div class="viewcode-block" id="TopologyObject"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject">[docs]</a><span class="k">class</span> <span class="nc">TopologyObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for all Topology items.</span>

<span class="sd">    Defines the behaviour by which Bonds/Angles/etc in MDAnalysis should</span>
<span class="sd">    behave.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       All TopologyObject now keep track of if they were guessed or not</span>
<span class="sd">       via the ``is_guessed`` managed property.</span>
<span class="sd">    .. versionadded:: 0.11.0</span>
<span class="sd">       Added the `value` method to return the size of the object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_ix&quot;</span><span class="p">,</span> <span class="s2">&quot;_u&quot;</span><span class="p">,</span> <span class="s2">&quot;btype&quot;</span><span class="p">,</span> <span class="s2">&quot;_bondtype&quot;</span><span class="p">,</span> <span class="s2">&quot;_guessed&quot;</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a topology object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ix : numpy array</span>
<span class="sd">          indices of the Atoms</span>
<span class="sd">        universe : MDAnalysis.Universe</span>
<span class="sd">        type : optional</span>
<span class="sd">          Type of the bond</span>
<span class="sd">        guessed : optional</span>
<span class="sd">          If the Bond is guessed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Atoms within this Bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of indices describing this object</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ix</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Type of the bond as a tuple</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When comparing types, it is important to consider the reverse</span>
<span class="sd">        of the type too, i.e.::</span>

<span class="sd">            a.type == b.type or a.type == b.type[::-1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">types</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;{cname} between: {conts}&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="n">conts</span><span class="o">=</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
                <span class="s2">&quot;Atom {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]))</span>

<div class="viewcode-block" id="TopologyObject.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether an atom is in this :class:`TopologyObject`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span></div>

<div class="viewcode-block" id="TopologyObject.__eq__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether two bonds have identical contents&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
                <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyObject.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyObject.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Can retrieve a given Atom from within&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">item</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bond"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond">[docs]</a><span class="k">class</span> <span class="nc">Bond</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A bond between two :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    Two :class:`Bond` instances can be compared with the ``==`` and</span>
<span class="sd">    ``!=`` operators. A bond is equal to another if the same atom</span>
<span class="sd">    numbers are connected and they have the same bond order. The</span>
<span class="sd">    ordering of the two atom numbers is ignored as is the fact that a</span>
<span class="sd">    bond was guessed.</span>

<span class="sd">    The presence of a particular atom can also be queried::</span>

<span class="sd">      &gt;&gt;&gt; Atom in Bond</span>

<span class="sd">    will return either ``True`` or ``False``.</span>

<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`. Changed class to use</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bond&#39;</span>

<div class="viewcode-block" id="Bond.partner"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.partner">[docs]</a>    <span class="k">def</span> <span class="nf">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bond.partner(Atom)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        the other :class:`~MDAnalysis.core.groups.Atom` in this</span>
<span class="sd">        bond</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">atom</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognised Atom&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bond.length"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Bond.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the bond.</span>

<span class="sd">        .. versionchanged:: 0.11.0</span>
<span class="sd">           Added pbc keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">self_distance_array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">]),</span>
                <span class="n">box</span><span class="o">=</span><span class="n">box</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div>

    <span class="n">value</span> <span class="o">=</span> <span class="n">length</span></div>


<div class="viewcode-block" id="Angle"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle">[docs]</a><span class="k">class</span> <span class="nc">Angle</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;An angle between three :class:`~MDAnalysis.core.groups.Atom` instances.</span>
<span class="sd">    Atom 2 is the apex of the angle</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses</span>
<span class="sd">       :attr:`__slots__` and stores atoms in :attr:`atoms` attribute</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;angle&#39;</span>

<div class="viewcode-block" id="Angle.angle"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Angle.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the angle in degrees of this Angle.</span>

<span class="sd">        Angle between atoms 0 and 2 with apex at 1::</span>

<span class="sd">              2</span>
<span class="sd">             /</span>
<span class="sd">            /</span>
<span class="sd">           1------0</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span></div>

    <span class="n">value</span> <span class="o">=</span> <span class="n">angle</span></div>


<div class="viewcode-block" id="Dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral">[docs]</a><span class="k">class</span> <span class="nc">Dihedral</span><span class="p">(</span><span class="n">TopologyObject</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Dihedral (dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    The dihedral is defined as the angle between the planes formed by</span>
<span class="sd">    Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Now a subclass of :class:`TopologyObject`; now uses :attr:`__slots__`</span>
<span class="sd">       and stores atoms in :attr:`atoms` attribute.</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to Dihedral (was Torsion)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/dihedral.png</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;dihedral&#39;</span>

<div class="viewcode-block" id="Dihedral.dihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.Dihedral.dihedral">[docs]</a>    <span class="k">def</span> <span class="nf">dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedral angle in degrees.</span>

<span class="sd">        Dihedral angle around axis connecting atoms 1 and 2 (i.e. the angle</span>
<span class="sd">        between the planes spanned by atoms (0,1,2) and (1,2,3))::</span>

<span class="sd">                  3</span>
<span class="sd">                  |</span>
<span class="sd">            1-----2</span>
<span class="sd">           /</span>
<span class="sd">          0</span>


<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">D</span><span class="o">.</span><span class="n">position</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dihedral</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">cd</span><span class="p">))</span></div>

    <span class="n">value</span> <span class="o">=</span> <span class="n">dihedral</span></div>


<span class="c1"># subclass Dihedral to inherit dihedral method</span>
<div class="viewcode-block" id="ImproperDihedral"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral">[docs]</a><span class="k">class</span> <span class="nc">ImproperDihedral</span><span class="p">(</span><span class="n">Dihedral</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improper Dihedral (improper dihedral angle) between four</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` instances.</span>

<span class="sd">    MDAnalysis treats the improper dihedral angle as the angle between</span>
<span class="sd">    the planes formed by Atoms (1, 2, 3) and (2, 3, 4).</span>

<span class="sd">    .. warning:: Definitions of Atom ordering in improper dihedrals</span>
<span class="sd">                 can change. Check the definitions here against</span>
<span class="sd">                 your software.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Renamed to ImproperDihedral (was Improper_Torsion)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># http://cbio.bmt.tue.nl/pumma/uploads/Theory/improper.png</span>
    <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;improper&#39;</span>

<div class="viewcode-block" id="ImproperDihedral.improper"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.ImproperDihedral.improper">[docs]</a>    <span class="k">def</span> <span class="nf">improper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Improper dihedral angle in degrees.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The numerical precision is typically not better than</span>
<span class="sd">        4 decimals (and is only tested to 3 decimals).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedral</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="TopologyDict"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict">[docs]</a><span class="k">class</span> <span class="nc">TopologyDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A customised dictionary designed for sorting the bonds, angles and</span>
<span class="sd">    dihedrals present in a group of atoms.</span>

<span class="sd">    Usage::</span>

<span class="sd">      topologydict = TopologyDict(members)</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    *members*</span>
<span class="sd">      A list of :class:`TopologyObject` instances</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    *topologydict*</span>
<span class="sd">      A specialised dictionary of the topology instances passed to it</span>

<span class="sd">    TopologyDicts are also built lazily from a :class:`TopologyGroup.topDict`</span>
<span class="sd">    attribute.</span>

<span class="sd">    The :class:`TopologyDict` collects all the selected topology type from the</span>
<span class="sd">    atoms and categorises them according to the types of the atoms within. A</span>
<span class="sd">    :class:`TopologyGroup` containing all of a given bond type can be made by</span>
<span class="sd">    querying with the appropriate key. The keys to the :class:`TopologyDict`</span>
<span class="sd">    are a tuple of the atom types that the bond represents and can be viewed</span>
<span class="sd">    using the :meth:`keys` method.</span>

<span class="sd">    For example, from a system containing pure ethanol ::</span>

<span class="sd">      &gt;&gt;&gt; td = u.bonds.topDict</span>
<span class="sd">      &gt;&gt;&gt; td.keys()</span>
<span class="sd">      [(&#39;C&#39;, &#39;C&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;O&#39;, &#39;H&#39;),</span>
<span class="sd">       (&#39;C&#39;, &#39;O&#39;)]</span>
<span class="sd">      &gt;&gt;&gt; td[&#39;C&#39;, &#39;O&#39;]</span>
<span class="sd">      &lt; TopologyGroup containing 912 bonds &gt;</span>

<span class="sd">    .. Note::</span>

<span class="sd">       The key for a bond is taken from the type attribute of the atoms.</span>

<span class="sd">       Getting and setting types of bonds is done smartly, so a C-C-H</span>
<span class="sd">       angle is considered identical to a H-C-C angle.</span>

<span class="sd">    Duplicate entries are automatically removed upon creation and</span>
<span class="sd">    combination of different Dicts.  This means a bond between atoms</span>
<span class="sd">    1 and 2 will only ever appear once in a dict despite both atoms 1</span>
<span class="sd">    and 2 having the bond in their :attr:`bond` attribute.</span>

<span class="sd">    Two :class:`TopologyDict` instances can be combined using</span>
<span class="sd">    addition and it will not create any duplicate bonds in the process.</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Changed initialisation to use a list of :class:`TopologyObject`</span>
<span class="sd">       instances instead of list of atoms; now used from within</span>
<span class="sd">       :class:`TopologyGroup` instead of accessed from :class:`AtomGroup`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topologygroup</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topologygroup</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only construct from TopologyGroup&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">topologygroup</span><span class="o">.</span><span class="n">universe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toptype</span> <span class="o">=</span> <span class="n">topologygroup</span><span class="o">.</span><span class="n">btype</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">topologygroup</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">type</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">btype</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_removeDupes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_removeDupes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts through contents and makes sure that there are</span>
<span class="sd">        no duplicate keys (through type reversal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Go through all keys, if the reverse of the key exists add this to</span>
        <span class="c1"># that entry else make a new entry</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">newdict</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newdict</span><span class="p">[</span><span class="n">k</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">newdict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

<div class="viewcode-block" id="TopologyDict.__len__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of types of bond in the topology dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="TopologyDict.keys"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the different types of available bonds&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopologyDict.__iter__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__iter__">[docs]</a>    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterator over keys in this dictionary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TopologyDict with {num} unique {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyDict.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a TopologyGroup matching the criteria if possible,</span>
<span class="sd">        otherwise returns ``None``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">bix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">indices</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">bix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">toptype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopologyDict.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyDict.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean on whether a given type exists within this dictionary</span>

<span class="sd">        For topology groups the key (1,2,3) is considered the same as (3,2,1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="ow">or</span> <span class="n">other</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span></div></div>


<div class="viewcode-block" id="TopologyGroup"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup">[docs]</a><span class="k">class</span> <span class="nc">TopologyGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A container for a groups of bonds.</span>

<span class="sd">    All bonds of a certain types can be retrieved from within the</span>
<span class="sd">    :class:`TopologyGroup` by querying with a tuple of types::</span>

<span class="sd">      tg2 = tg.select_bonds([key])</span>

<span class="sd">    Where *key* describes the desired bond as a tuple of the involved</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.Atom` types, as defined by the .type Atom</span>
<span class="sd">    attribute). A list of available keys can be displayed using the</span>
<span class="sd">    :meth:`types` method.</span>

<span class="sd">    Alternatively, all the bonds which are in a given</span>
<span class="sd">    :class:`~MDAnalysis.core.groups.AtomGroup` can be extracted using</span>
<span class="sd">    :meth:`atomgroup_intersection`::</span>

<span class="sd">      tg2 = tg.atomgroup_intersection(ag)</span>

<span class="sd">    This allows the keyword *strict* to be given, which forces all members of</span>
<span class="sd">    all bonds to be inside the AtomGroup passed to it.</span>

<span class="sd">    Finally, a TopologyGroup can be sliced similarly to AtomGroups::</span>

<span class="sd">      tg2 = tg[5:10]</span>

<span class="sd">    The :meth:`bonds`, :meth:`angles` and :meth:`dihedrals` methods offer</span>
<span class="sd">    a &quot;shortcut&quot; to the Cython distance calculation functions in</span>
<span class="sd">    :class:`MDAnalysis.lib.distances`.</span>

<span class="sd">    TopologyGroups can be combined with TopologyGroups of the same bond</span>
<span class="sd">    type (ie can combine two angle containing TopologyGroups).</span>

<span class="sd">    .. versionadded:: 0.8</span>
<span class="sd">    .. versionchanged:: 0.9.0</span>
<span class="sd">       Overhauled completely: (1) Added internal :class:`TopologyDict`</span>
<span class="sd">       accessible by the :attr:`topDict` attribute. (2)</span>
<span class="sd">       :meth:`selectBonds` allows the :attr:`topDict` to be queried</span>
<span class="sd">       with tuple of types. (3) Added :meth:`atomgroup_intersection`</span>
<span class="sd">       to allow bonds which are in a given :class:`AtomGroup` to be retrieved.</span>
<span class="sd">    .. versionchanged:: 0.10.0</span>
<span class="sd">       Added :func:`from_indices` constructor, allowing class to be created</span>
<span class="sd">       from indices.</span>
<span class="sd">       Can now create empty Group.</span>
<span class="sd">       Renamed :meth:`dump_contents` to :meth:`to_indices`</span>
<span class="sd">    .. versionchanged:: 0.11.0</span>
<span class="sd">       Added `values` method to return the size of each object in this group</span>
<span class="sd">       Deprecated selectBonds method in favour of select_bonds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_allowed_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bond&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;dihedral&#39;</span><span class="p">,</span> <span class="s1">&#39;improper&#39;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bondidx</span><span class="p">,</span> <span class="n">universe</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># guess what I am</span>
            <span class="c1"># difference between dihedral and improper</span>
            <span class="c1"># not really important</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;bond&#39;</span><span class="p">,</span>
                          <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span>
                          <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;dihedral&#39;</span><span class="p">}[</span><span class="nb">len</span><span class="p">(</span><span class="n">bondidx</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allowed_types</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">=</span> <span class="n">btype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported btype, use one of {}&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_allowed_types</span><span class="p">))</span>

        <span class="n">nbonds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bondidx</span><span class="p">)</span>
        <span class="c1"># remove duplicate bonds</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">guessed</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">guessed</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">guessed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">nbonds</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nbonds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># TODO: why has this been defined?</span>
        <span class="n">split_index</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bond&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                       <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                       <span class="s1">&#39;improper&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">nbonds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">uniq</span><span class="p">,</span> <span class="n">uniq_idx</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">unique_rows</span><span class="p">(</span><span class="n">bondidx</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span> <span class="o">=</span> <span class="n">uniq</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span> <span class="o">=</span> <span class="nb">type</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="n">uniq_idx</span><span class="p">]</span>

            <span class="c1"># Create vertical AtomGroups</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span> <span class="o">=</span> <span class="p">[</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]]</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Empty TopologyGroup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_u</span> <span class="o">=</span> <span class="n">universe</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># used for topdict saving</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span>

<div class="viewcode-block" id="TopologyGroup.select_bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.select_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">select_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves a selection from this topology group based on types.</span>

<span class="sd">        .. seeAlso :meth:`types`</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span></div>

    <span class="n">selectBonds</span> <span class="o">=</span> <span class="n">select_bonds</span>

<div class="viewcode-block" id="TopologyGroup.types"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.types">[docs]</a>    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the bond types in this TopologyGroup</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topDict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;dict&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">topDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TopologyDict for this topology group.</span>

<span class="sd">        This is used for the select_bonds method when fetching a certain type</span>
<span class="sd">        of bond.</span>

<span class="sd">        This is a cached property so will be generated the first time it is</span>
<span class="sd">        accessed.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TopologyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.atomgroup_intersection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.atomgroup_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">atomgroup_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all bonds from within this TopologyGroup that are within</span>
<span class="sd">        the AtomGroup which is passed.</span>

<span class="sd">        Keywords</span>
<span class="sd">        --------</span>
<span class="sd">          *strict*</span>
<span class="sd">            Only retrieve bonds which are completely contained within the</span>
<span class="sd">            AtomGroup. [``False``]</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Issue #780 - if self is empty, return self to avoid invalid mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Strict requires all items in a row to be seen,</span>
        <span class="c1"># otherwise any item in a row</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;strict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span>

        <span class="n">atom_idx</span> <span class="o">=</span> <span class="n">ag</span><span class="o">.</span><span class="n">indices</span>
        <span class="c1"># Create a list of boolean arrays,</span>
        <span class="c1"># each representing a column of bond indices.</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">atom_idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>

        <span class="c1"># Create final boolean mask by summing across rows</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span>

<div class="viewcode-block" id="TopologyGroup.to_indices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.to_indices">[docs]</a>    <span class="k">def</span> <span class="nf">to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of tuples which define the contents of this</span>
<span class="sd">        TopologyGroup in terms of the atom numbers,</span>
<span class="sd">        (0 based index within u.atoms)</span>

<span class="sd">        This format should be identical to the original contents of the</span>
<span class="sd">        entries in universe._topology.</span>
<span class="sd">        Note that because bonds are sorted as they are initialised, the order</span>
<span class="sd">        that atoms are defined in each entry might be reversed.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Renamed from &quot;dump_contents&quot; to &quot;to_indices&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span></div>

    <span class="n">dump_contents</span> <span class="o">=</span> <span class="n">to_indices</span>

<div class="viewcode-block" id="TopologyGroup.__len__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__len__">[docs]</a>    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of bonds in the topology group&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TopologyGroup.__add__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two TopologyGroups together.</span>

<span class="sd">        Can combined two TopologyGroup of the same type, or add a single</span>
<span class="sd">        TopologyObject to a TopologyGroup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check addition is sane</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">TopologyObject</span><span class="p">,</span> <span class="n">TopologyGroup</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only combine TopologyObject or &quot;</span>
                            <span class="s2">&quot;TopologyGroup to TopologyGroup, not {0}&quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="c1"># cases where either other or self is empty TG</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>  <span class="c1"># adding empty TG to me</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="c1"># Reshape indices to be 2d array</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:],</span>
                                     <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                                     <span class="n">btype</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                     <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtype</span><span class="p">]),</span>
                                     <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">is_guessed</span><span class="p">]),</span>
                                     <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">order</span><span class="p">]),</span>
                                     <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                     <span class="n">other</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                                     <span class="n">btype</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                     <span class="nb">type</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span>
                                     <span class="n">guessed</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span>
                                     <span class="n">order</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span>
                                     <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot add different types of &quot;</span>
                                <span class="s2">&quot;TopologyObjects together&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TopologyObject</span><span class="p">):</span>
                <span class="c1"># add TO to me</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                    <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_bondtype</span><span class="p">])]),</span>
                    <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">other</span><span class="o">.</span><span class="n">is_guessed</span><span class="p">]])]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">order</span><span class="p">])]),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># add TG to me</span>
                <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">,</span>
                    <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                    <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">]),</span>
                    <span class="n">guessed</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_guessed</span><span class="p">]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_order</span><span class="p">]),</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="TopologyGroup.__getitem__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a particular bond as single object or a subset of</span>
<span class="sd">        this TopologyGroup as another TopologyGroup</span>

<span class="sd">        .. versionchanged:: 0.10.0</span>
<span class="sd">           Allows indexing via boolean numpy array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab a single Item, similar to Atom/AtomGroup relationship</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">outclass</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bond&#39;</span><span class="p">:</span> <span class="n">Bond</span><span class="p">,</span>
                        <span class="s1">&#39;angle&#39;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
                        <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span> <span class="n">Dihedral</span><span class="p">,</span>
                        <span class="s1">&#39;improper&#39;</span><span class="p">:</span> <span class="n">ImproperDihedral</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">outclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span>
                            <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                            <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Slice my index array with the item</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bix</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span>
                                  <span class="n">btype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">,</span>
                                  <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondtypes</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="n">guessed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">[</span><span class="n">item</span><span class="p">],</span>
                                  <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">[</span><span class="n">item</span><span class="p">],)</span></div>

<div class="viewcode-block" id="TopologyGroup.__contains__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__contains__">[docs]</a>    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tests if this TopologyGroup contains a bond&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bix</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TopologyGroup containing {num} {type}s&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btype</span><span class="p">)</span>

<div class="viewcode-block" id="TopologyGroup.__eq__"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if contents of TopologyGroups are equal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># Distance calculation methods below</span>
    <span class="c1"># &quot;Slow&quot; versions exist as a way of testing the Cython implementations</span>
<div class="viewcode-block" id="TopologyGroup.values"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the size of each object in this Group</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [``False``]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        .. versionadded:: 0.11.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;improper&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dihedrals</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_bondsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of bond (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bond&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bond_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>
            <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
                <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
                <span class="c1"># orthogonal and divide by zero check</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="mf">90.</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">bond_dist</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">bond_dist</span> <span class="o">/</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only orthogonal boxes supported&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">bond_dist</span><span class="p">])</span>

<div class="viewcode-block" id="TopologyGroup.bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.bonds">[docs]</a>    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the distance between all bonds in this TopologyGroup</span>

<span class="sd">        :Keywords:</span>
<span class="sd">           *pbc*</span>
<span class="sd">              apply periodic boundary conditions when calculating distance</span>
<span class="sd">              [False]</span>
<span class="sd">           *result*</span>
<span class="sd">              allows a predefined results array to be used,</span>
<span class="sd">              note that this will be overwritten</span>

<span class="sd">        Uses cython implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;bond&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;bond&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_bonds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                        <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_anglesSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of angle (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;angle&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>

        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">slowang</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">angles</span>

<div class="viewcode-block" id="TopologyGroup.angles"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.angles">[docs]</a>    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the angle in radians formed between a bond</span>
<span class="sd">        between atoms 1 and 2 and a bond between atoms 2 &amp; 3</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : array_like</span>
<span class="sd">            allows a predefined results array to be used, note that this</span>
<span class="sd">            will be overwritten</span>
<span class="sd">        pbc : bool</span>
<span class="sd">            apply periodic boundary conditions when calculating angles</span>
<span class="sd">            [``False``] this is important when connecting vectors between</span>
<span class="sd">            atoms might require minimum image convention</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray</span>

<span class="sd">        .. versionchanged :: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;angle&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                         <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_dihedralsSlow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Slow version of dihedral (numpy implementation)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dihedral&#39;</span><span class="p">,</span> <span class="s1">&#39;improper&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;dihedral&#39; or &quot;</span>
                            <span class="s2">&quot;&#39;improper&#39;&quot;</span><span class="p">)</span>

        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">vec3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dihedral</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">,</span> <span class="n">vec3</span><span class="p">)])</span>

<div class="viewcode-block" id="TopologyGroup.dihedrals"><a class="viewcode-back" href="../../../documentation_pages/core/topologyobjects.html#MDAnalysis.core.topologyobjects.TopologyGroup.dihedrals">[docs]</a>    <span class="k">def</span> <span class="nf">dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the dihedralal angle in radians for this topology</span>
<span class="sd">        group.</span>

<span class="sd">        Defined as the angle between a plane formed by atoms 1, 2 and</span>
<span class="sd">        3 and a plane formed by atoms 2, 3 and 4.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : array_like</span>
<span class="sd">            allows a predefined results array to be used, note that this</span>
<span class="sd">            will be overwritten</span>
<span class="sd">        pbc : bool</span>
<span class="sd">            apply periodic boundary conditions when calculating angles</span>
<span class="sd">            [``False``] this is important when connecting vectors between</span>
<span class="sd">            atoms might require minimum image convention</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        angles : ndarray</span>

<span class="sd">        .. versionchanged:: 0.9.0</span>
<span class="sd">           Added *pbc* option (default ``False``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">btype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dihedral&#39;</span><span class="p">,</span> <span class="s1">&#39;improper&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TopologyGroup is not of type &#39;dihedral&#39; or &quot;</span>
                            <span class="s2">&quot;&#39;improper&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
                                            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">distances</span><span class="o">.</span><span class="n">calc_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_ags</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span>
                                            <span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">MDAnalysis 0.16.0-dev0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2015, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Balasubramanian, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Wouter Boomsma, Bart Bruininks, Sbastien Buchoux, David Caplan, Matthieu Chavent, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Matteo Tiberti, Isaac Virshup, Zhuyi Xue, and Oliver Beckstein.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>